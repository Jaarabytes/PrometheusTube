// Package routes provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package routes

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ApproveDownloadParams defines parameters for ApproveDownload.
type ApproveDownloadParams struct {
	// VideoID video ID to download
	VideoID int `json:"videoID"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// ApproveVideoParams defines parameters for ApproveVideo.
type ApproveVideoParams struct {
	// VideoID video ID to download
	VideoID int `json:"videoID"`

	// Mature auth cookies etc
	Mature *bool `json:"mature,omitempty"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// ArchiveEventsParams defines parameters for ArchiveEvents.
type ArchiveEventsParams struct {
	// DownloadID download id to filter on
	DownloadID string `json:"downloadID"`
}

// ArchiveRequestsParams defines parameters for ArchiveRequests.
type ArchiveRequestsParams struct {
	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// AuditEventsParams defines parameters for AuditEvents.
type AuditEventsParams struct {
	// PageNumber content page number
	PageNumber int `json:"pageNumber"`

	// Id user id to filter on
	Id int `json:"id"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// CommentParams defines parameters for Comment.
type CommentParams struct {
	// Parent parent comment ID
	Parent int `json:"parent"`

	// Content comment message
	Content []byte `json:"content"`

	// VideoID comment's video ID
	VideoID int `json:"videoID"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateDanmakuParams defines parameters for CreateDanmaku.
type CreateDanmakuParams struct {
	// VideoID video ID for danmaku
	VideoID int `json:"VideoID"`

	// Timestamp timestamp for danmaku
	Timestamp string `json:"timestamp"`

	// Message message
	Message []byte `json:"message"`

	// Type type of comment
	Type string `json:"Type"`

	// Color comment color
	Color string `json:"Color"`

	// FontSize comment font size
	FontSize string `json:"FontSize"`
}

// DeleteArchiveRequestParams defines parameters for DeleteArchiveRequest.
type DeleteArchiveRequestParams struct {
	// DownloadID download ID of the request to retry
	DownloadID int `json:"downloadID"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// DeleteCommentParams defines parameters for DeleteComment.
type DeleteCommentParams struct {
	// Id comment ID
	Id int `json:"id"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// EmailValidationParams defines parameters for EmailValidation.
type EmailValidationParams struct {
	// Email email
	Email string `json:"email"`
}

// FollowFeedParams defines parameters for FollowFeed.
type FollowFeedParams struct {
	// ShowMature show mature
	ShowMature bool `json:"showMature"`
}

// GetUnapprovedVideosParams defines parameters for GetUnapprovedVideos.
type GetUnapprovedVideosParams struct {
	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// LoginParams defines parameters for Login.
type LoginParams struct {
	// Username search string
	Username string `form:"username" json:"username"`

	// Password sort category
	Password string `form:"password" json:"password"`
}

// NewArchiveRequestParams defines parameters for NewArchiveRequest.
type NewArchiveRequestParams struct {
	// Url url to archive
	Url string `json:"url"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// RecommendationsParams defines parameters for Recommendations.
type RecommendationsParams struct {
	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`

	// ShowMature user ID
	ShowMature bool `json:"showMature"`
}

// RegisterParams defines parameters for Register.
type RegisterParams struct {
	// VerificationCode verification code
	VerificationCode int `form:"VerificationCode" json:"VerificationCode"`

	// Username username to register
	Username string `json:"username"`

	// Password sort category
	Password string `json:"password"`

	// Email sort category
	Email string `json:"email"`
}

// ResetPasswordParams defines parameters for ResetPassword.
type ResetPasswordParams struct {
	// Oldpassword old password
	Oldpassword string `json:"oldpassword"`

	// Newpassword new password
	Newpassword string `json:"newpassword"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// RetryArchiveRequestParams defines parameters for RetryArchiveRequest.
type RetryArchiveRequestParams struct {
	// DownloadID download ID of the request to retry
	DownloadID int `json:"downloadID"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// UnapproveDownloadParams defines parameters for UnapproveDownload.
type UnapproveDownloadParams struct {
	// VideoID video ID to download
	VideoID int `json:"videoID"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateProfileParams defines parameters for UpdateProfile.
type UpdateProfileParams struct {
	// Username new username
	Username []byte `json:"username"`

	// Gender new gender
	Gender []byte `json:"gender"`

	// Birthdate new birthdate
	Birthdate string `json:"birthdate"`

	// Bio new bio
	Bio []byte `json:"bio"`
}

// UploadMultipartBody defines parameters for Upload.
type UploadMultipartBody struct {
	Filename *[]openapi_types.File `json:"filename,omitempty"`
}

// UploadParams defines parameters for Upload.
type UploadParams struct {
	// Tags list of video tags
	Tags []string `json:"tags"`

	// Title video title
	Title string `json:"title"`

	// Description video description
	Description string `json:"description"`

	// Category category
	Category string `json:"category"`
}

// UpvoteParams defines parameters for Upvote.
type UpvoteParams struct {
	// Score upvote score
	Score float32 `json:"score"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// UpvoteVideoParams defines parameters for UpvoteVideo.
type UpvoteVideoParams struct {
	// Score upvote score
	Score int `json:"score"`

	// Cookie auth cookies etc
	Cookie *string `json:"Cookie,omitempty"`
}

// UsersParams defines parameters for Users.
type UsersParams struct {
	// ShowMature user ID
	ShowMature bool `json:"showMature"`
}

// VideosParams defines parameters for Videos.
type VideosParams struct {
	// Search search string
	Search *[]byte `json:"search,omitempty"`

	// SortCategory sort category
	SortCategory *string `json:"sortCategory,omitempty"`

	// Order sort category
	Order *string `json:"order,omitempty"`

	// Unapproved sort category
	Unapproved *string `json:"unapproved,omitempty"`

	// ShowMature show mature
	ShowMature bool `json:"showMature"`

	// PageNumber page number
	PageNumber *int `json:"pageNumber,omitempty"`

	// Category category
	Category *[]byte `json:"category,omitempty"`
}

// UploadMultipartRequestBody defines body for Upload for multipart/form-data ContentType.
type UploadMultipartRequestBody UploadMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ApproveDownload request
	ApproveDownload(ctx context.Context, params *ApproveDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveVideo request
	ApproveVideo(ctx context.Context, params *ApproveVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveEvents request
	ArchiveEvents(ctx context.Context, params *ArchiveEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveRequests request
	ArchiveRequests(ctx context.Context, params *ArchiveRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuditEvents request
	AuditEvents(ctx context.Context, params *AuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Comment request
	Comment(ctx context.Context, params *CommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Comments request
	Comments(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDanmaku request
	CreateDanmaku(ctx context.Context, params *CreateDanmakuParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDanmaku request
	GetDanmaku(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteArchiveRequest request
	DeleteArchiveRequest(ctx context.Context, params *DeleteArchiveRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComment request
	DeleteComment(ctx context.Context, params *DeleteCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailValidation request
	EmailValidation(ctx context.Context, params *EmailValidationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FollowFeed request
	FollowFeed(ctx context.Context, params *FollowFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Follow request
	Follow(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnapprovedVideos request
	GetUnapprovedVideos(ctx context.Context, params *GetUnapprovedVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request
	Login(ctx context.Context, params *LoginParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewArchiveRequest request
	NewArchiveRequest(ctx context.Context, params *NewArchiveRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Recommendations request
	Recommendations(ctx context.Context, id int, params *RecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Register request
	Register(ctx context.Context, params *RegisterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPassword request
	ResetPassword(ctx context.Context, params *ResetPasswordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryArchiveRequest request
	RetryArchiveRequest(ctx context.Context, params *RetryArchiveRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnapproveDownload request
	UnapproveDownload(ctx context.Context, params *UnapproveDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProfile request
	UpdateProfile(ctx context.Context, params *UpdateProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Upload request with any body
	UploadWithBody(ctx context.Context, params *UploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Upvote request
	Upvote(ctx context.Context, id int, params *UpvoteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpvoteVideo request
	UpvoteVideo(ctx context.Context, id int, params *UpvoteVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Users request
	Users(ctx context.Context, id int, params *UsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Videos request
	Videos(ctx context.Context, params *VideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VideoDetail request
	VideoDetail(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ApproveDownload(ctx context.Context, params *ApproveDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveDownloadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveVideo(ctx context.Context, params *ApproveVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveVideoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveEvents(ctx context.Context, params *ArchiveEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveRequests(ctx context.Context, params *ArchiveRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuditEvents(ctx context.Context, params *AuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Comment(ctx context.Context, params *CommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Comments(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommentsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDanmaku(ctx context.Context, params *CreateDanmakuParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDanmakuRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDanmaku(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDanmakuRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteArchiveRequest(ctx context.Context, params *DeleteArchiveRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteArchiveRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComment(ctx context.Context, params *DeleteCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailValidation(ctx context.Context, params *EmailValidationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailValidationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FollowFeed(ctx context.Context, params *FollowFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowFeedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Follow(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnapprovedVideos(ctx context.Context, params *GetUnapprovedVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnapprovedVideosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, params *LoginParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewArchiveRequest(ctx context.Context, params *NewArchiveRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewArchiveRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Recommendations(ctx context.Context, id int, params *RecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Register(ctx context.Context, params *RegisterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, params *ResetPasswordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryArchiveRequest(ctx context.Context, params *RetryArchiveRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryArchiveRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnapproveDownload(ctx context.Context, params *UnapproveDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnapproveDownloadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfile(ctx context.Context, params *UpdateProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadWithBody(ctx context.Context, params *UploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Upvote(ctx context.Context, id int, params *UpvoteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpvoteRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpvoteVideo(ctx context.Context, id int, params *UpvoteVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpvoteVideoRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Users(ctx context.Context, id int, params *UsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Videos(ctx context.Context, params *VideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVideosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VideoDetail(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVideoDetailRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewApproveDownloadRequest generates requests for ApproveDownload
func NewApproveDownloadRequest(server string, params *ApproveDownloadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/approve-download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "videoID", runtime.ParamLocationHeader, params.VideoID)
	if err != nil {
		return nil, err
	}

	req.Header.Set("videoID", headerParam0)

	if params.Cookie != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam1)
	}

	return req, nil
}

// NewApproveVideoRequest generates requests for ApproveVideo
func NewApproveVideoRequest(server string, params *ApproveVideoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/approve-video")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "videoID", runtime.ParamLocationHeader, params.VideoID)
	if err != nil {
		return nil, err
	}

	req.Header.Set("videoID", headerParam0)

	if params.Mature != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "mature", runtime.ParamLocationHeader, *params.Mature)
		if err != nil {
			return nil, err
		}

		req.Header.Set("mature", headerParam1)
	}

	if params.Cookie != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam2)
	}

	return req, nil
}

// NewArchiveEventsRequest generates requests for ArchiveEvents
func NewArchiveEventsRequest(server string, params *ArchiveEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/archive-events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "downloadID", runtime.ParamLocationHeader, params.DownloadID)
	if err != nil {
		return nil, err
	}

	req.Header.Set("downloadID", headerParam0)

	return req, nil
}

// NewArchiveRequestsRequest generates requests for ArchiveRequests
func NewArchiveRequestsRequest(server string, params *ArchiveRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/archive-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Cookie != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam0)
	}

	return req, nil
}

// NewAuditEventsRequest generates requests for AuditEvents
func NewAuditEventsRequest(server string, params *AuditEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audit-events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "pageNumber", runtime.ParamLocationHeader, params.PageNumber)
	if err != nil {
		return nil, err
	}

	req.Header.Set("pageNumber", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationHeader, params.Id)
	if err != nil {
		return nil, err
	}

	req.Header.Set("id", headerParam1)

	if params.Cookie != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam2)
	}

	return req, nil
}

// NewCommentRequest generates requests for Comment
func NewCommentRequest(server string, params *CommentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "parent", runtime.ParamLocationHeader, params.Parent)
	if err != nil {
		return nil, err
	}

	req.Header.Set("parent", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "content", runtime.ParamLocationHeader, params.Content)
	if err != nil {
		return nil, err
	}

	req.Header.Set("content", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "videoID", runtime.ParamLocationHeader, params.VideoID)
	if err != nil {
		return nil, err
	}

	req.Header.Set("videoID", headerParam2)

	if params.Cookie != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam3)
	}

	return req, nil
}

// NewCommentsRequest generates requests for Comments
func NewCommentsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDanmakuRequest generates requests for CreateDanmaku
func NewCreateDanmakuRequest(server string, params *CreateDanmakuParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/danmaku")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "VideoID", runtime.ParamLocationHeader, params.VideoID)
	if err != nil {
		return nil, err
	}

	req.Header.Set("VideoID", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationHeader, params.Timestamp)
	if err != nil {
		return nil, err
	}

	req.Header.Set("timestamp", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "message", runtime.ParamLocationHeader, params.Message)
	if err != nil {
		return nil, err
	}

	req.Header.Set("message", headerParam2)

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "Type", runtime.ParamLocationHeader, params.Type)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Type", headerParam3)

	var headerParam4 string

	headerParam4, err = runtime.StyleParamWithLocation("simple", false, "Color", runtime.ParamLocationHeader, params.Color)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Color", headerParam4)

	var headerParam5 string

	headerParam5, err = runtime.StyleParamWithLocation("simple", false, "FontSize", runtime.ParamLocationHeader, params.FontSize)
	if err != nil {
		return nil, err
	}

	req.Header.Set("FontSize", headerParam5)

	return req, nil
}

// NewGetDanmakuRequest generates requests for GetDanmaku
func NewGetDanmakuRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/danmaku/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteArchiveRequestRequest generates requests for DeleteArchiveRequest
func NewDeleteArchiveRequestRequest(server string, params *DeleteArchiveRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/delete-archive-request")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "downloadID", runtime.ParamLocationHeader, params.DownloadID)
	if err != nil {
		return nil, err
	}

	req.Header.Set("downloadID", headerParam0)

	if params.Cookie != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam1)
	}

	return req, nil
}

// NewDeleteCommentRequest generates requests for DeleteComment
func NewDeleteCommentRequest(server string, params *DeleteCommentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/delete_comment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationHeader, params.Id)
	if err != nil {
		return nil, err
	}

	req.Header.Set("id", headerParam0)

	if params.Cookie != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam1)
	}

	return req, nil
}

// NewEmailValidationRequest generates requests for EmailValidation
func NewEmailValidationRequest(server string, params *EmailValidationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/email-verification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationHeader, params.Email)
	if err != nil {
		return nil, err
	}

	req.Header.Set("email", headerParam0)

	return req, nil
}

// NewFollowFeedRequest generates requests for FollowFeed
func NewFollowFeedRequest(server string, params *FollowFeedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/follow-feed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "showMature", runtime.ParamLocationHeader, params.ShowMature)
	if err != nil {
		return nil, err
	}

	req.Header.Set("showMature", headerParam0)

	return req, nil
}

// NewFollowRequest generates requests for Follow
func NewFollowRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/follow/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnapprovedVideosRequest generates requests for GetUnapprovedVideos
func NewGetUnapprovedVideosRequest(server string, params *GetUnapprovedVideosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/get-unapproved-videos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Cookie != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam0)
	}

	return req, nil
}

// NewLoginRequest generates requests for Login
func NewLoginRequest(server string, params *LoginParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("form", false, "username", runtime.ParamLocationHeader, params.Username)
	if err != nil {
		return nil, err
	}

	req.Header.Set("username", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("form", false, "password", runtime.ParamLocationHeader, params.Password)
	if err != nil {
		return nil, err
	}

	req.Header.Set("password", headerParam1)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewArchiveRequestRequest generates requests for NewArchiveRequest
func NewNewArchiveRequestRequest(server string, params *NewArchiveRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/new-archive-request")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "url", runtime.ParamLocationHeader, params.Url)
	if err != nil {
		return nil, err
	}

	req.Header.Set("url", headerParam0)

	if params.Cookie != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam1)
	}

	return req, nil
}

// NewRecommendationsRequest generates requests for Recommendations
func NewRecommendationsRequest(server string, id int, params *RecommendationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Cookie != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam0)
	}

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "showMature", runtime.ParamLocationHeader, params.ShowMature)
	if err != nil {
		return nil, err
	}

	req.Header.Set("showMature", headerParam1)

	return req, nil
}

// NewRegisterRequest generates requests for Register
func NewRegisterRequest(server string, params *RegisterParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "VerificationCode", runtime.ParamLocationQuery, params.VerificationCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationHeader, params.Username)
	if err != nil {
		return nil, err
	}

	req.Header.Set("username", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "password", runtime.ParamLocationHeader, params.Password)
	if err != nil {
		return nil, err
	}

	req.Header.Set("password", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationHeader, params.Email)
	if err != nil {
		return nil, err
	}

	req.Header.Set("email", headerParam2)

	return req, nil
}

// NewResetPasswordRequest generates requests for ResetPassword
func NewResetPasswordRequest(server string, params *ResetPasswordParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reset_password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "oldpassword", runtime.ParamLocationHeader, params.Oldpassword)
	if err != nil {
		return nil, err
	}

	req.Header.Set("oldpassword", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "newpassword", runtime.ParamLocationHeader, params.Newpassword)
	if err != nil {
		return nil, err
	}

	req.Header.Set("newpassword", headerParam1)

	if params.Cookie != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam2)
	}

	return req, nil
}

// NewRetryArchiveRequestRequest generates requests for RetryArchiveRequest
func NewRetryArchiveRequestRequest(server string, params *RetryArchiveRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/retry-archive-request")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "downloadID", runtime.ParamLocationHeader, params.DownloadID)
	if err != nil {
		return nil, err
	}

	req.Header.Set("downloadID", headerParam0)

	if params.Cookie != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam1)
	}

	return req, nil
}

// NewUnapproveDownloadRequest generates requests for UnapproveDownload
func NewUnapproveDownloadRequest(server string, params *UnapproveDownloadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unapprove-download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "videoID", runtime.ParamLocationHeader, params.VideoID)
	if err != nil {
		return nil, err
	}

	req.Header.Set("videoID", headerParam0)

	if params.Cookie != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam1)
	}

	return req, nil
}

// NewUpdateProfileRequest generates requests for UpdateProfile
func NewUpdateProfileRequest(server string, params *UpdateProfileParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/update-profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationHeader, params.Username)
	if err != nil {
		return nil, err
	}

	req.Header.Set("username", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "gender", runtime.ParamLocationHeader, params.Gender)
	if err != nil {
		return nil, err
	}

	req.Header.Set("gender", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "birthdate", runtime.ParamLocationHeader, params.Birthdate)
	if err != nil {
		return nil, err
	}

	req.Header.Set("birthdate", headerParam2)

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "bio", runtime.ParamLocationHeader, params.Bio)
	if err != nil {
		return nil, err
	}

	req.Header.Set("bio", headerParam3)

	return req, nil
}

// NewUploadRequestWithBody generates requests for Upload with any type of body
func NewUploadRequestWithBody(server string, params *UploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "tags", runtime.ParamLocationHeader, params.Tags)
	if err != nil {
		return nil, err
	}

	req.Header.Set("tags", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "title", runtime.ParamLocationHeader, params.Title)
	if err != nil {
		return nil, err
	}

	req.Header.Set("title", headerParam1)

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "description", runtime.ParamLocationHeader, params.Description)
	if err != nil {
		return nil, err
	}

	req.Header.Set("description", headerParam2)

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationHeader, params.Category)
	if err != nil {
		return nil, err
	}

	req.Header.Set("category", headerParam3)

	return req, nil
}

// NewUpvoteRequest generates requests for Upvote
func NewUpvoteRequest(server string, id int, params *UpvoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upvote/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "score", runtime.ParamLocationHeader, params.Score)
	if err != nil {
		return nil, err
	}

	req.Header.Set("score", headerParam0)

	if params.Cookie != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam1)
	}

	return req, nil
}

// NewUpvoteVideoRequest generates requests for UpvoteVideo
func NewUpvoteVideoRequest(server string, id int, params *UpvoteVideoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upvotevideo/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "score", runtime.ParamLocationHeader, params.Score)
	if err != nil {
		return nil, err
	}

	req.Header.Set("score", headerParam0)

	if params.Cookie != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Cookie", headerParam1)
	}

	return req, nil
}

// NewUsersRequest generates requests for Users
func NewUsersRequest(server string, id int, params *UsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "showMature", runtime.ParamLocationHeader, params.ShowMature)
	if err != nil {
		return nil, err
	}

	req.Header.Set("showMature", headerParam0)

	return req, nil
}

// NewVideosRequest generates requests for Videos
func NewVideosRequest(server string, params *VideosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Search != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "search", runtime.ParamLocationHeader, *params.Search)
		if err != nil {
			return nil, err
		}

		req.Header.Set("search", headerParam0)
	}

	if params.SortCategory != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "sortCategory", runtime.ParamLocationHeader, *params.SortCategory)
		if err != nil {
			return nil, err
		}

		req.Header.Set("sortCategory", headerParam1)
	}

	if params.Order != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "order", runtime.ParamLocationHeader, *params.Order)
		if err != nil {
			return nil, err
		}

		req.Header.Set("order", headerParam2)
	}

	if params.Unapproved != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "unapproved", runtime.ParamLocationHeader, *params.Unapproved)
		if err != nil {
			return nil, err
		}

		req.Header.Set("unapproved", headerParam3)
	}

	var headerParam4 string

	headerParam4, err = runtime.StyleParamWithLocation("simple", false, "showMature", runtime.ParamLocationHeader, params.ShowMature)
	if err != nil {
		return nil, err
	}

	req.Header.Set("showMature", headerParam4)

	if params.PageNumber != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "pageNumber", runtime.ParamLocationHeader, *params.PageNumber)
		if err != nil {
			return nil, err
		}

		req.Header.Set("pageNumber", headerParam5)
	}

	if params.Category != nil {
		var headerParam6 string

		headerParam6, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationHeader, *params.Category)
		if err != nil {
			return nil, err
		}

		req.Header.Set("category", headerParam6)
	}

	return req, nil
}

// NewVideoDetailRequest generates requests for VideoDetail
func NewVideoDetailRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ApproveDownload request
	ApproveDownloadWithResponse(ctx context.Context, params *ApproveDownloadParams, reqEditors ...RequestEditorFn) (*ApproveDownloadResponse, error)

	// ApproveVideo request
	ApproveVideoWithResponse(ctx context.Context, params *ApproveVideoParams, reqEditors ...RequestEditorFn) (*ApproveVideoResponse, error)

	// ArchiveEvents request
	ArchiveEventsWithResponse(ctx context.Context, params *ArchiveEventsParams, reqEditors ...RequestEditorFn) (*ArchiveEventsResponse, error)

	// ArchiveRequests request
	ArchiveRequestsWithResponse(ctx context.Context, params *ArchiveRequestsParams, reqEditors ...RequestEditorFn) (*ArchiveRequestsResponse, error)

	// AuditEvents request
	AuditEventsWithResponse(ctx context.Context, params *AuditEventsParams, reqEditors ...RequestEditorFn) (*AuditEventsResponse, error)

	// Comment request
	CommentWithResponse(ctx context.Context, params *CommentParams, reqEditors ...RequestEditorFn) (*CommentResponse, error)

	// Comments request
	CommentsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CommentsResponse, error)

	// CreateDanmaku request
	CreateDanmakuWithResponse(ctx context.Context, params *CreateDanmakuParams, reqEditors ...RequestEditorFn) (*CreateDanmakuResponse, error)

	// GetDanmaku request
	GetDanmakuWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetDanmakuResponse, error)

	// DeleteArchiveRequest request
	DeleteArchiveRequestWithResponse(ctx context.Context, params *DeleteArchiveRequestParams, reqEditors ...RequestEditorFn) (*DeleteArchiveRequestResponse, error)

	// DeleteComment request
	DeleteCommentWithResponse(ctx context.Context, params *DeleteCommentParams, reqEditors ...RequestEditorFn) (*DeleteCommentResponse, error)

	// EmailValidation request
	EmailValidationWithResponse(ctx context.Context, params *EmailValidationParams, reqEditors ...RequestEditorFn) (*EmailValidationResponse, error)

	// FollowFeed request
	FollowFeedWithResponse(ctx context.Context, params *FollowFeedParams, reqEditors ...RequestEditorFn) (*FollowFeedResponse, error)

	// Follow request
	FollowWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FollowResponse, error)

	// GetUnapprovedVideos request
	GetUnapprovedVideosWithResponse(ctx context.Context, params *GetUnapprovedVideosParams, reqEditors ...RequestEditorFn) (*GetUnapprovedVideosResponse, error)

	// Login request
	LoginWithResponse(ctx context.Context, params *LoginParams, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// Logout request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// NewArchiveRequest request
	NewArchiveRequestWithResponse(ctx context.Context, params *NewArchiveRequestParams, reqEditors ...RequestEditorFn) (*NewArchiveRequestResponse, error)

	// Recommendations request
	RecommendationsWithResponse(ctx context.Context, id int, params *RecommendationsParams, reqEditors ...RequestEditorFn) (*RecommendationsResponse, error)

	// Register request
	RegisterWithResponse(ctx context.Context, params *RegisterParams, reqEditors ...RequestEditorFn) (*RegisterResponse, error)

	// ResetPassword request
	ResetPasswordWithResponse(ctx context.Context, params *ResetPasswordParams, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// RetryArchiveRequest request
	RetryArchiveRequestWithResponse(ctx context.Context, params *RetryArchiveRequestParams, reqEditors ...RequestEditorFn) (*RetryArchiveRequestResponse, error)

	// UnapproveDownload request
	UnapproveDownloadWithResponse(ctx context.Context, params *UnapproveDownloadParams, reqEditors ...RequestEditorFn) (*UnapproveDownloadResponse, error)

	// UpdateProfile request
	UpdateProfileWithResponse(ctx context.Context, params *UpdateProfileParams, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	// Upload request with any body
	UploadWithBodyWithResponse(ctx context.Context, params *UploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadResponse, error)

	// Upvote request
	UpvoteWithResponse(ctx context.Context, id int, params *UpvoteParams, reqEditors ...RequestEditorFn) (*UpvoteResponse, error)

	// UpvoteVideo request
	UpvoteVideoWithResponse(ctx context.Context, id int, params *UpvoteVideoParams, reqEditors ...RequestEditorFn) (*UpvoteVideoResponse, error)

	// Users request
	UsersWithResponse(ctx context.Context, id int, params *UsersParams, reqEditors ...RequestEditorFn) (*UsersResponse, error)

	// Videos request
	VideosWithResponse(ctx context.Context, params *VideosParams, reqEditors ...RequestEditorFn) (*VideosResponse, error)

	// VideoDetail request
	VideoDetailWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*VideoDetailResponse, error)
}

type ApproveDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ApproveDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ApproveVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Message   *string `json:"Message,omitempty"`
		ParnetUrl *string `json:"ParnetUrl,omitempty"`
		Timestamp *string `json:"Timestamp,omitempty"`
		VideoUrl  *string `json:"VideoUrl,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ArchiveEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		ArchivedVideos       *int    `json:"ArchivedVideos,omitempty"`
		BackoffFactor        *int    `json:"BackoffFactor,omitempty"`
		CurrentTotalVideos   *int    `json:"CurrentTotalVideos,omitempty"`
		DownloadID           *int    `json:"DownloadID,omitempty"`
		LastSynced           *string `json:"LastSynced,omitempty"`
		UndownloadableVideos *int    `json:"UndownloadableVideos,omitempty"`
		Url                  *string `json:"Url,omitempty"`
		UserID               *int    `json:"UserID,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ArchiveRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuditEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		ArchivedVideos       *int    `json:"ArchivedVideos,omitempty"`
		BackoffFactor        *int    `json:"BackoffFactor,omitempty"`
		CurrentTotalVideos   *int    `json:"CurrentTotalVideos,omitempty"`
		DownloadID           *int    `json:"DownloadID,omitempty"`
		LastSynced           *string `json:"LastSynced,omitempty"`
		UndownloadableVideos *int    `json:"UndownloadableVideos,omitempty"`
		Url                  *string `json:"Url,omitempty"`
		UserID               *int    `json:"UserID,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuditEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuditEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		AuthoredByCurrentUser *bool    `json:"authored_by_current_user,omitempty"`
		Content               *string  `json:"content,omitempty"`
		Created               *string  `json:"created,omitempty"`
		Fullname              *string  `json:"fullname,omitempty"`
		Id                    *float32 `json:"id,omitempty"`
		ProfilePictureUrl     *string  `json:"profile_picture_url,omitempty"`
		UpvoteCount           *float32 `json:"upvote_count,omitempty"`
		UserHasDownvoted      *bool    `json:"user_has_downvoted,omitempty"`
		UserHasUpvoted        *bool    `json:"user_has_upvoted,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDanmakuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateDanmakuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDanmakuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDanmakuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		AuthorID     *int    `json:"AuthorID,omitempty"`
		Color        *string `json:"Color,omitempty"`
		CreationDate *string `json:"CreationDate,omitempty"`
		FontSize     *string `json:"FontSize,omitempty"`
		ID           *int    `json:"ID,omitempty"`
		Message      *string `json:"Message,omitempty"`
		Timestamp    *string `json:"Timestamp,omitempty"`
		Type         *string `json:"Type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDanmakuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDanmakuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteArchiveRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteArchiveRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteArchiveRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EmailValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FollowFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		AuthorID      *float32 `json:"AuthorID,omitempty"`
		AuthorName    *string  `json:"AuthorName,omitempty"`
		Rating        *float32 `json:"Rating,omitempty"`
		ThumbnailLoc  *string  `json:"ThumbnailLoc,omitempty"`
		Title         *string  `json:"Title,omitempty"`
		VideoDuration *float32 `json:"VideoDuration,omitempty"`
		VideoID       *float32 `json:"VideoID,omitempty"`
		Views         *float32 `json:"Views,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FollowFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FollowFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FollowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FollowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FollowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnapprovedVideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Category *int    `json:"Category,omitempty"`
		URL      *string `json:"URL,omitempty"`
		VideoID  *int    `json:"VideoID,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUnapprovedVideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnapprovedVideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewArchiveRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NewArchiveRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewArchiveRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		AuthorID      *float32 `json:"AuthorID,omitempty"`
		AuthorName    *string  `json:"AuthorName,omitempty"`
		Rating        *float32 `json:"Rating,omitempty"`
		ThumbnailLoc  *string  `json:"ThumbnailLoc,omitempty"`
		Title         *string  `json:"Title,omitempty"`
		VideoDuration *float32 `json:"VideoDuration,omitempty"`
		VideoID       *float32 `json:"VideoID,omitempty"`
		Views         *float32 `json:"Views,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RegisterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryArchiveRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RetryArchiveRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryArchiveRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnapproveDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnapproveDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnapproveDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpvoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpvoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpvoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpvoteVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpvoteVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpvoteVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Bio            *string `json:"Bio,omitempty"`
		Birthdate      *string `json:"Birthdate,omitempty"`
		Gender         *string `json:"Gender,omitempty"`
		JoinDate       *string `json:"JoinDate,omitempty"`
		PaginationData *struct {
			CurrentPage   *float32 `json:"CurrentPage,omitempty"`
			NumberOfItems *float32 `json:"NumberOfItems,omitempty"`
		} `json:"PaginationData,omitempty"`
		ProfilePictureURL *string  `json:"ProfilePictureURL,omitempty"`
		UserID            *float32 `json:"UserID,omitempty"`
		Username          *string  `json:"Username,omitempty"`
		Videos            *[]struct {
			AuthorID      *float32 `json:"AuthorID,omitempty"`
			AuthorName    *string  `json:"AuthorName,omitempty"`
			Rating        *float32 `json:"Rating,omitempty"`
			ThumbnailLoc  *string  `json:"ThumbnailLoc,omitempty"`
			Title         *string  `json:"Title,omitempty"`
			VideoDuration *float32 `json:"VideoDuration,omitempty"`
			VideoID       *float32 `json:"VideoID,omitempty"`
			Views         *float32 `json:"Views,omitempty"`
		} `json:"Videos,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Categories *[]struct {
			Cardinality *float32 `json:"Cardinality,omitempty"`
			Name        *string  `json:"Name,omitempty"`
		} `json:"Categories,omitempty"`
		PaginationData *struct {
			CurrentPage   *float32 `json:"CurrentPage,omitempty"`
			NumberOfItems *float32 `json:"NumberOfItems,omitempty"`
		} `json:"PaginationData,omitempty"`
		ProfilePictureURL *string  `json:"ProfilePictureURL,omitempty"`
		UserID            *float32 `json:"UserID,omitempty"`
		Username          *string  `json:"Username,omitempty"`
		Videos            *[]struct {
			AuthorID      *float32 `json:"AuthorID,omitempty"`
			AuthorName    *string  `json:"AuthorName,omitempty"`
			Rating        *float32 `json:"Rating,omitempty"`
			ThumbnailLoc  *string  `json:"ThumbnailLoc,omitempty"`
			Title         *string  `json:"Title,omitempty"`
			VideoDuration *float32 `json:"VideoDuration,omitempty"`
			VideoID       *float32 `json:"VideoID,omitempty"`
			Views         *float32 `json:"Views,omitempty"`
		} `json:"Videos,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VideoDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AuthorID         *float32                `json:"AuthorID,omitempty"`
		Comments         *map[string]interface{} `json:"Comments,omitempty"`
		MPDLoc           *string                 `json:"MPDLoc,omitempty"`
		ProfilePicture   *string                 `json:"ProfilePicture,omitempty"`
		Rating           *float32                `json:"Rating,omitempty"`
		Tags             *[]string               `json:"Tags,omitempty"`
		Thumbnail        *string                 `json:"Thumbnail,omitempty"`
		Title            *string                 `json:"Title,omitempty"`
		UploadDate       *string                 `json:"UploadDate,omitempty"`
		UserDescription  *string                 `json:"UserDescription,omitempty"`
		UserSubscribers  *float32                `json:"UserSubscribers,omitempty"`
		Username         *string                 `json:"Username,omitempty"`
		VideoDescription *string                 `json:"VideoDescription,omitempty"`
		VideoDuration    *float32                `json:"VideoDuration,omitempty"`
		VideoID          *float32                `json:"VideoID,omitempty"`
		Views            *float32                `json:"Views,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VideoDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VideoDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ApproveDownloadWithResponse request returning *ApproveDownloadResponse
func (c *ClientWithResponses) ApproveDownloadWithResponse(ctx context.Context, params *ApproveDownloadParams, reqEditors ...RequestEditorFn) (*ApproveDownloadResponse, error) {
	rsp, err := c.ApproveDownload(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveDownloadResponse(rsp)
}

// ApproveVideoWithResponse request returning *ApproveVideoResponse
func (c *ClientWithResponses) ApproveVideoWithResponse(ctx context.Context, params *ApproveVideoParams, reqEditors ...RequestEditorFn) (*ApproveVideoResponse, error) {
	rsp, err := c.ApproveVideo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveVideoResponse(rsp)
}

// ArchiveEventsWithResponse request returning *ArchiveEventsResponse
func (c *ClientWithResponses) ArchiveEventsWithResponse(ctx context.Context, params *ArchiveEventsParams, reqEditors ...RequestEditorFn) (*ArchiveEventsResponse, error) {
	rsp, err := c.ArchiveEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveEventsResponse(rsp)
}

// ArchiveRequestsWithResponse request returning *ArchiveRequestsResponse
func (c *ClientWithResponses) ArchiveRequestsWithResponse(ctx context.Context, params *ArchiveRequestsParams, reqEditors ...RequestEditorFn) (*ArchiveRequestsResponse, error) {
	rsp, err := c.ArchiveRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveRequestsResponse(rsp)
}

// AuditEventsWithResponse request returning *AuditEventsResponse
func (c *ClientWithResponses) AuditEventsWithResponse(ctx context.Context, params *AuditEventsParams, reqEditors ...RequestEditorFn) (*AuditEventsResponse, error) {
	rsp, err := c.AuditEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditEventsResponse(rsp)
}

// CommentWithResponse request returning *CommentResponse
func (c *ClientWithResponses) CommentWithResponse(ctx context.Context, params *CommentParams, reqEditors ...RequestEditorFn) (*CommentResponse, error) {
	rsp, err := c.Comment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommentResponse(rsp)
}

// CommentsWithResponse request returning *CommentsResponse
func (c *ClientWithResponses) CommentsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CommentsResponse, error) {
	rsp, err := c.Comments(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommentsResponse(rsp)
}

// CreateDanmakuWithResponse request returning *CreateDanmakuResponse
func (c *ClientWithResponses) CreateDanmakuWithResponse(ctx context.Context, params *CreateDanmakuParams, reqEditors ...RequestEditorFn) (*CreateDanmakuResponse, error) {
	rsp, err := c.CreateDanmaku(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDanmakuResponse(rsp)
}

// GetDanmakuWithResponse request returning *GetDanmakuResponse
func (c *ClientWithResponses) GetDanmakuWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetDanmakuResponse, error) {
	rsp, err := c.GetDanmaku(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDanmakuResponse(rsp)
}

// DeleteArchiveRequestWithResponse request returning *DeleteArchiveRequestResponse
func (c *ClientWithResponses) DeleteArchiveRequestWithResponse(ctx context.Context, params *DeleteArchiveRequestParams, reqEditors ...RequestEditorFn) (*DeleteArchiveRequestResponse, error) {
	rsp, err := c.DeleteArchiveRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteArchiveRequestResponse(rsp)
}

// DeleteCommentWithResponse request returning *DeleteCommentResponse
func (c *ClientWithResponses) DeleteCommentWithResponse(ctx context.Context, params *DeleteCommentParams, reqEditors ...RequestEditorFn) (*DeleteCommentResponse, error) {
	rsp, err := c.DeleteComment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommentResponse(rsp)
}

// EmailValidationWithResponse request returning *EmailValidationResponse
func (c *ClientWithResponses) EmailValidationWithResponse(ctx context.Context, params *EmailValidationParams, reqEditors ...RequestEditorFn) (*EmailValidationResponse, error) {
	rsp, err := c.EmailValidation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailValidationResponse(rsp)
}

// FollowFeedWithResponse request returning *FollowFeedResponse
func (c *ClientWithResponses) FollowFeedWithResponse(ctx context.Context, params *FollowFeedParams, reqEditors ...RequestEditorFn) (*FollowFeedResponse, error) {
	rsp, err := c.FollowFeed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowFeedResponse(rsp)
}

// FollowWithResponse request returning *FollowResponse
func (c *ClientWithResponses) FollowWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FollowResponse, error) {
	rsp, err := c.Follow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowResponse(rsp)
}

// GetUnapprovedVideosWithResponse request returning *GetUnapprovedVideosResponse
func (c *ClientWithResponses) GetUnapprovedVideosWithResponse(ctx context.Context, params *GetUnapprovedVideosParams, reqEditors ...RequestEditorFn) (*GetUnapprovedVideosResponse, error) {
	rsp, err := c.GetUnapprovedVideos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnapprovedVideosResponse(rsp)
}

// LoginWithResponse request returning *LoginResponse
func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, params *LoginParams, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// NewArchiveRequestWithResponse request returning *NewArchiveRequestResponse
func (c *ClientWithResponses) NewArchiveRequestWithResponse(ctx context.Context, params *NewArchiveRequestParams, reqEditors ...RequestEditorFn) (*NewArchiveRequestResponse, error) {
	rsp, err := c.NewArchiveRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewArchiveRequestResponse(rsp)
}

// RecommendationsWithResponse request returning *RecommendationsResponse
func (c *ClientWithResponses) RecommendationsWithResponse(ctx context.Context, id int, params *RecommendationsParams, reqEditors ...RequestEditorFn) (*RecommendationsResponse, error) {
	rsp, err := c.Recommendations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendationsResponse(rsp)
}

// RegisterWithResponse request returning *RegisterResponse
func (c *ClientWithResponses) RegisterWithResponse(ctx context.Context, params *RegisterParams, reqEditors ...RequestEditorFn) (*RegisterResponse, error) {
	rsp, err := c.Register(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResponse(rsp)
}

// ResetPasswordWithResponse request returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, params *ResetPasswordParams, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// RetryArchiveRequestWithResponse request returning *RetryArchiveRequestResponse
func (c *ClientWithResponses) RetryArchiveRequestWithResponse(ctx context.Context, params *RetryArchiveRequestParams, reqEditors ...RequestEditorFn) (*RetryArchiveRequestResponse, error) {
	rsp, err := c.RetryArchiveRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryArchiveRequestResponse(rsp)
}

// UnapproveDownloadWithResponse request returning *UnapproveDownloadResponse
func (c *ClientWithResponses) UnapproveDownloadWithResponse(ctx context.Context, params *UnapproveDownloadParams, reqEditors ...RequestEditorFn) (*UnapproveDownloadResponse, error) {
	rsp, err := c.UnapproveDownload(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnapproveDownloadResponse(rsp)
}

// UpdateProfileWithResponse request returning *UpdateProfileResponse
func (c *ClientWithResponses) UpdateProfileWithResponse(ctx context.Context, params *UpdateProfileParams, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfile(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

// UploadWithBodyWithResponse request with arbitrary body returning *UploadResponse
func (c *ClientWithResponses) UploadWithBodyWithResponse(ctx context.Context, params *UploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadResponse, error) {
	rsp, err := c.UploadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadResponse(rsp)
}

// UpvoteWithResponse request returning *UpvoteResponse
func (c *ClientWithResponses) UpvoteWithResponse(ctx context.Context, id int, params *UpvoteParams, reqEditors ...RequestEditorFn) (*UpvoteResponse, error) {
	rsp, err := c.Upvote(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpvoteResponse(rsp)
}

// UpvoteVideoWithResponse request returning *UpvoteVideoResponse
func (c *ClientWithResponses) UpvoteVideoWithResponse(ctx context.Context, id int, params *UpvoteVideoParams, reqEditors ...RequestEditorFn) (*UpvoteVideoResponse, error) {
	rsp, err := c.UpvoteVideo(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpvoteVideoResponse(rsp)
}

// UsersWithResponse request returning *UsersResponse
func (c *ClientWithResponses) UsersWithResponse(ctx context.Context, id int, params *UsersParams, reqEditors ...RequestEditorFn) (*UsersResponse, error) {
	rsp, err := c.Users(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersResponse(rsp)
}

// VideosWithResponse request returning *VideosResponse
func (c *ClientWithResponses) VideosWithResponse(ctx context.Context, params *VideosParams, reqEditors ...RequestEditorFn) (*VideosResponse, error) {
	rsp, err := c.Videos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVideosResponse(rsp)
}

// VideoDetailWithResponse request returning *VideoDetailResponse
func (c *ClientWithResponses) VideoDetailWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*VideoDetailResponse, error) {
	rsp, err := c.VideoDetail(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVideoDetailResponse(rsp)
}

// ParseApproveDownloadResponse parses an HTTP response from a ApproveDownloadWithResponse call
func ParseApproveDownloadResponse(rsp *http.Response) (*ApproveDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseApproveVideoResponse parses an HTTP response from a ApproveVideoWithResponse call
func ParseApproveVideoResponse(rsp *http.Response) (*ApproveVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveEventsResponse parses an HTTP response from a ArchiveEventsWithResponse call
func ParseArchiveEventsResponse(rsp *http.Response) (*ArchiveEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Message   *string `json:"Message,omitempty"`
			ParnetUrl *string `json:"ParnetUrl,omitempty"`
			Timestamp *string `json:"Timestamp,omitempty"`
			VideoUrl  *string `json:"VideoUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveRequestsResponse parses an HTTP response from a ArchiveRequestsWithResponse call
func ParseArchiveRequestsResponse(rsp *http.Response) (*ArchiveRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			ArchivedVideos       *int    `json:"ArchivedVideos,omitempty"`
			BackoffFactor        *int    `json:"BackoffFactor,omitempty"`
			CurrentTotalVideos   *int    `json:"CurrentTotalVideos,omitempty"`
			DownloadID           *int    `json:"DownloadID,omitempty"`
			LastSynced           *string `json:"LastSynced,omitempty"`
			UndownloadableVideos *int    `json:"UndownloadableVideos,omitempty"`
			Url                  *string `json:"Url,omitempty"`
			UserID               *int    `json:"UserID,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuditEventsResponse parses an HTTP response from a AuditEventsWithResponse call
func ParseAuditEventsResponse(rsp *http.Response) (*AuditEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuditEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			ArchivedVideos       *int    `json:"ArchivedVideos,omitempty"`
			BackoffFactor        *int    `json:"BackoffFactor,omitempty"`
			CurrentTotalVideos   *int    `json:"CurrentTotalVideos,omitempty"`
			DownloadID           *int    `json:"DownloadID,omitempty"`
			LastSynced           *string `json:"LastSynced,omitempty"`
			UndownloadableVideos *int    `json:"UndownloadableVideos,omitempty"`
			Url                  *string `json:"Url,omitempty"`
			UserID               *int    `json:"UserID,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCommentResponse parses an HTTP response from a CommentWithResponse call
func ParseCommentResponse(rsp *http.Response) (*CommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCommentsResponse parses an HTTP response from a CommentsWithResponse call
func ParseCommentsResponse(rsp *http.Response) (*CommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			AuthoredByCurrentUser *bool    `json:"authored_by_current_user,omitempty"`
			Content               *string  `json:"content,omitempty"`
			Created               *string  `json:"created,omitempty"`
			Fullname              *string  `json:"fullname,omitempty"`
			Id                    *float32 `json:"id,omitempty"`
			ProfilePictureUrl     *string  `json:"profile_picture_url,omitempty"`
			UpvoteCount           *float32 `json:"upvote_count,omitempty"`
			UserHasDownvoted      *bool    `json:"user_has_downvoted,omitempty"`
			UserHasUpvoted        *bool    `json:"user_has_upvoted,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDanmakuResponse parses an HTTP response from a CreateDanmakuWithResponse call
func ParseCreateDanmakuResponse(rsp *http.Response) (*CreateDanmakuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDanmakuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDanmakuResponse parses an HTTP response from a GetDanmakuWithResponse call
func ParseGetDanmakuResponse(rsp *http.Response) (*GetDanmakuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDanmakuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			AuthorID     *int    `json:"AuthorID,omitempty"`
			Color        *string `json:"Color,omitempty"`
			CreationDate *string `json:"CreationDate,omitempty"`
			FontSize     *string `json:"FontSize,omitempty"`
			ID           *int    `json:"ID,omitempty"`
			Message      *string `json:"Message,omitempty"`
			Timestamp    *string `json:"Timestamp,omitempty"`
			Type         *string `json:"Type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteArchiveRequestResponse parses an HTTP response from a DeleteArchiveRequestWithResponse call
func ParseDeleteArchiveRequestResponse(rsp *http.Response) (*DeleteArchiveRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteArchiveRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteCommentResponse parses an HTTP response from a DeleteCommentWithResponse call
func ParseDeleteCommentResponse(rsp *http.Response) (*DeleteCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEmailValidationResponse parses an HTTP response from a EmailValidationWithResponse call
func ParseEmailValidationResponse(rsp *http.Response) (*EmailValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFollowFeedResponse parses an HTTP response from a FollowFeedWithResponse call
func ParseFollowFeedResponse(rsp *http.Response) (*FollowFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FollowFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			AuthorID      *float32 `json:"AuthorID,omitempty"`
			AuthorName    *string  `json:"AuthorName,omitempty"`
			Rating        *float32 `json:"Rating,omitempty"`
			ThumbnailLoc  *string  `json:"ThumbnailLoc,omitempty"`
			Title         *string  `json:"Title,omitempty"`
			VideoDuration *float32 `json:"VideoDuration,omitempty"`
			VideoID       *float32 `json:"VideoID,omitempty"`
			Views         *float32 `json:"Views,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFollowResponse parses an HTTP response from a FollowWithResponse call
func ParseFollowResponse(rsp *http.Response) (*FollowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FollowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUnapprovedVideosResponse parses an HTTP response from a GetUnapprovedVideosWithResponse call
func ParseGetUnapprovedVideosResponse(rsp *http.Response) (*GetUnapprovedVideosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnapprovedVideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Category *int    `json:"Category,omitempty"`
			URL      *string `json:"URL,omitempty"`
			VideoID  *int    `json:"VideoID,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNewArchiveRequestResponse parses an HTTP response from a NewArchiveRequestWithResponse call
func ParseNewArchiveRequestResponse(rsp *http.Response) (*NewArchiveRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewArchiveRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRecommendationsResponse parses an HTTP response from a RecommendationsWithResponse call
func ParseRecommendationsResponse(rsp *http.Response) (*RecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			AuthorID      *float32 `json:"AuthorID,omitempty"`
			AuthorName    *string  `json:"AuthorName,omitempty"`
			Rating        *float32 `json:"Rating,omitempty"`
			ThumbnailLoc  *string  `json:"ThumbnailLoc,omitempty"`
			Title         *string  `json:"Title,omitempty"`
			VideoDuration *float32 `json:"VideoDuration,omitempty"`
			VideoID       *float32 `json:"VideoID,omitempty"`
			Views         *float32 `json:"Views,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterResponse parses an HTTP response from a RegisterWithResponse call
func ParseRegisterResponse(rsp *http.Response) (*RegisterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRetryArchiveRequestResponse parses an HTTP response from a RetryArchiveRequestWithResponse call
func ParseRetryArchiveRequestResponse(rsp *http.Response) (*RetryArchiveRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryArchiveRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnapproveDownloadResponse parses an HTTP response from a UnapproveDownloadWithResponse call
func ParseUnapproveDownloadResponse(rsp *http.Response) (*UnapproveDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnapproveDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateProfileResponse parses an HTTP response from a UpdateProfileWithResponse call
func ParseUpdateProfileResponse(rsp *http.Response) (*UpdateProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUploadResponse parses an HTTP response from a UploadWithResponse call
func ParseUploadResponse(rsp *http.Response) (*UploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpvoteResponse parses an HTTP response from a UpvoteWithResponse call
func ParseUpvoteResponse(rsp *http.Response) (*UpvoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpvoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpvoteVideoResponse parses an HTTP response from a UpvoteVideoWithResponse call
func ParseUpvoteVideoResponse(rsp *http.Response) (*UpvoteVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpvoteVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUsersResponse parses an HTTP response from a UsersWithResponse call
func ParseUsersResponse(rsp *http.Response) (*UsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Bio            *string `json:"Bio,omitempty"`
			Birthdate      *string `json:"Birthdate,omitempty"`
			Gender         *string `json:"Gender,omitempty"`
			JoinDate       *string `json:"JoinDate,omitempty"`
			PaginationData *struct {
				CurrentPage   *float32 `json:"CurrentPage,omitempty"`
				NumberOfItems *float32 `json:"NumberOfItems,omitempty"`
			} `json:"PaginationData,omitempty"`
			ProfilePictureURL *string  `json:"ProfilePictureURL,omitempty"`
			UserID            *float32 `json:"UserID,omitempty"`
			Username          *string  `json:"Username,omitempty"`
			Videos            *[]struct {
				AuthorID      *float32 `json:"AuthorID,omitempty"`
				AuthorName    *string  `json:"AuthorName,omitempty"`
				Rating        *float32 `json:"Rating,omitempty"`
				ThumbnailLoc  *string  `json:"ThumbnailLoc,omitempty"`
				Title         *string  `json:"Title,omitempty"`
				VideoDuration *float32 `json:"VideoDuration,omitempty"`
				VideoID       *float32 `json:"VideoID,omitempty"`
				Views         *float32 `json:"Views,omitempty"`
			} `json:"Videos,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVideosResponse parses an HTTP response from a VideosWithResponse call
func ParseVideosResponse(rsp *http.Response) (*VideosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Categories *[]struct {
				Cardinality *float32 `json:"Cardinality,omitempty"`
				Name        *string  `json:"Name,omitempty"`
			} `json:"Categories,omitempty"`
			PaginationData *struct {
				CurrentPage   *float32 `json:"CurrentPage,omitempty"`
				NumberOfItems *float32 `json:"NumberOfItems,omitempty"`
			} `json:"PaginationData,omitempty"`
			ProfilePictureURL *string  `json:"ProfilePictureURL,omitempty"`
			UserID            *float32 `json:"UserID,omitempty"`
			Username          *string  `json:"Username,omitempty"`
			Videos            *[]struct {
				AuthorID      *float32 `json:"AuthorID,omitempty"`
				AuthorName    *string  `json:"AuthorName,omitempty"`
				Rating        *float32 `json:"Rating,omitempty"`
				ThumbnailLoc  *string  `json:"ThumbnailLoc,omitempty"`
				Title         *string  `json:"Title,omitempty"`
				VideoDuration *float32 `json:"VideoDuration,omitempty"`
				VideoID       *float32 `json:"VideoID,omitempty"`
				Views         *float32 `json:"Views,omitempty"`
			} `json:"Videos,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVideoDetailResponse parses an HTTP response from a VideoDetailWithResponse call
func ParseVideoDetailResponse(rsp *http.Response) (*VideoDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VideoDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AuthorID         *float32                `json:"AuthorID,omitempty"`
			Comments         *map[string]interface{} `json:"Comments,omitempty"`
			MPDLoc           *string                 `json:"MPDLoc,omitempty"`
			ProfilePicture   *string                 `json:"ProfilePicture,omitempty"`
			Rating           *float32                `json:"Rating,omitempty"`
			Tags             *[]string               `json:"Tags,omitempty"`
			Thumbnail        *string                 `json:"Thumbnail,omitempty"`
			Title            *string                 `json:"Title,omitempty"`
			UploadDate       *string                 `json:"UploadDate,omitempty"`
			UserDescription  *string                 `json:"UserDescription,omitempty"`
			UserSubscribers  *float32                `json:"UserSubscribers,omitempty"`
			Username         *string                 `json:"Username,omitempty"`
			VideoDescription *string                 `json:"VideoDescription,omitempty"`
			VideoDuration    *float32                `json:"VideoDuration,omitempty"`
			VideoID          *float32                `json:"VideoID,omitempty"`
			Views            *float32                `json:"Views,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retry archive request
	// (POST /approve-download)
	ApproveDownload(ctx echo.Context, params ApproveDownloadParams) error
	// Retry archive request
	// (POST /approve-video)
	ApproveVideo(ctx echo.Context, params ApproveVideoParams) error
	// Get archive events
	// (GET /archive-events)
	ArchiveEvents(ctx echo.Context, params ArchiveEventsParams) error
	// Get archive requests
	// (GET /archive-requests)
	ArchiveRequests(ctx echo.Context, params ArchiveRequestsParams) error
	// Get archive requests
	// (GET /audit-events)
	AuditEvents(ctx echo.Context, params AuditEventsParams) error
	// Comment on a video
	// (POST /comment)
	Comment(ctx echo.Context, params CommentParams) error
	// Get comments for video ID
	// (GET /comments/{id})
	Comments(ctx echo.Context, id int) error
	// Create new danmaku
	// (POST /danmaku)
	CreateDanmaku(ctx echo.Context, params CreateDanmakuParams) error
	// Get danmaku for video
	// (GET /danmaku/{id})
	GetDanmaku(ctx echo.Context, id int) error
	// Retry archive request
	// (POST /delete-archive-request)
	DeleteArchiveRequest(ctx echo.Context, params DeleteArchiveRequestParams) error
	// Delete a comment
	// (POST /delete_comment)
	DeleteComment(ctx echo.Context, params DeleteCommentParams) error
	// Create new email validation
	// (POST /email-verification)
	EmailValidation(ctx echo.Context, params EmailValidationParams) error
	// Upvote a video
	// (GET /follow-feed)
	FollowFeed(ctx echo.Context, params FollowFeedParams) error
	// Upvote a video
	// (POST /follow/{id})
	Follow(ctx echo.Context, id int) error
	// Retry archive request
	// (GET /get-unapproved-videos)
	GetUnapprovedVideos(ctx echo.Context, params GetUnapprovedVideosParams) error
	// Log the user in
	// (POST /login)
	Login(ctx echo.Context, params LoginParams) error
	// Log user out
	// (GET /logout)
	Logout(ctx echo.Context) error
	// Create new archive request
	// (POST /new-archive-request)
	NewArchiveRequest(ctx echo.Context, params NewArchiveRequestParams) error
	// Get list of videos
	// (GET /recommendations/{id})
	Recommendations(ctx echo.Context, id int, params RecommendationsParams) error
	// Register user
	// (POST /register)
	Register(ctx echo.Context, params RegisterParams) error
	// Reset password
	// (POST /reset_password)
	ResetPassword(ctx echo.Context, params ResetPasswordParams) error
	// Retry archive request
	// (POST /retry-archive-request)
	RetryArchiveRequest(ctx echo.Context, params RetryArchiveRequestParams) error
	// Retry archive request
	// (POST /unapprove-download)
	UnapproveDownload(ctx echo.Context, params UnapproveDownloadParams) error
	// Update user's profile
	// (POST /update-profile)
	UpdateProfile(ctx echo.Context, params UpdateProfileParams) error
	// Upload a new video
	// (POST /upload)
	Upload(ctx echo.Context, params UploadParams) error
	// Get user video data
	// (GET /upvote/{id})
	Upvote(ctx echo.Context, id int, params UpvoteParams) error
	// Upvote a video
	// (POST /upvotevideo/{id})
	UpvoteVideo(ctx echo.Context, id int, params UpvoteVideoParams) error
	// Get user video data
	// (GET /users/{id})
	Users(ctx echo.Context, id int, params UsersParams) error
	// Get list of videos
	// (GET /videos)
	Videos(ctx echo.Context, params VideosParams) error
	// Get list of videos
	// (GET /videos/{id})
	VideoDetail(ctx echo.Context, id float32) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ApproveDownload converts echo context to params.
func (w *ServerInterfaceWrapper) ApproveDownload(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ApproveDownloadParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "videoID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("videoID")]; found {
		var VideoID int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for videoID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "videoID", runtime.ParamLocationHeader, valueList[0], &VideoID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoID: %s", err))
		}

		params.VideoID = VideoID
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter videoID is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ApproveDownload(ctx, params)
	return err
}

// ApproveVideo converts echo context to params.
func (w *ServerInterfaceWrapper) ApproveVideo(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ApproveVideoParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "videoID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("videoID")]; found {
		var VideoID int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for videoID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "videoID", runtime.ParamLocationHeader, valueList[0], &VideoID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoID: %s", err))
		}

		params.VideoID = VideoID
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter videoID is required, but not found"))
	}
	// ------------- Optional header parameter "mature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("mature")]; found {
		var Mature bool
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for mature, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "mature", runtime.ParamLocationHeader, valueList[0], &Mature)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mature: %s", err))
		}

		params.Mature = &Mature
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ApproveVideo(ctx, params)
	return err
}

// ArchiveEvents converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveEvents(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ArchiveEventsParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "downloadID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("downloadID")]; found {
		var DownloadID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for downloadID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "downloadID", runtime.ParamLocationHeader, valueList[0], &DownloadID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter downloadID: %s", err))
		}

		params.DownloadID = DownloadID
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter downloadID is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ArchiveEvents(ctx, params)
	return err
}

// ArchiveRequests converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveRequests(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ArchiveRequestsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ArchiveRequests(ctx, params)
	return err
}

// AuditEvents converts echo context to params.
func (w *ServerInterfaceWrapper) AuditEvents(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuditEventsParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "pageNumber" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("pageNumber")]; found {
		var PageNumber int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for pageNumber, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "pageNumber", runtime.ParamLocationHeader, valueList[0], &PageNumber)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageNumber: %s", err))
		}

		params.PageNumber = PageNumber
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter pageNumber is required, but not found"))
	}
	// ------------- Required header parameter "id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("id")]; found {
		var Id int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationHeader, valueList[0], &Id)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
		}

		params.Id = Id
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter id is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuditEvents(ctx, params)
	return err
}

// Comment converts echo context to params.
func (w *ServerInterfaceWrapper) Comment(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CommentParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "parent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("parent")]; found {
		var Parent int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for parent, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "parent", runtime.ParamLocationHeader, valueList[0], &Parent)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent: %s", err))
		}

		params.Parent = Parent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter parent is required, but not found"))
	}
	// ------------- Required header parameter "content" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("content")]; found {
		var Content []byte
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for content, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "content", runtime.ParamLocationHeader, valueList[0], &Content)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter content: %s", err))
		}

		params.Content = Content
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter content is required, but not found"))
	}
	// ------------- Required header parameter "videoID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("videoID")]; found {
		var VideoID int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for videoID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "videoID", runtime.ParamLocationHeader, valueList[0], &VideoID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoID: %s", err))
		}

		params.VideoID = VideoID
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter videoID is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Comment(ctx, params)
	return err
}

// Comments converts echo context to params.
func (w *ServerInterfaceWrapper) Comments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Comments(ctx, id)
	return err
}

// CreateDanmaku converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDanmaku(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateDanmakuParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "VideoID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("VideoID")]; found {
		var VideoID int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for VideoID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "VideoID", runtime.ParamLocationHeader, valueList[0], &VideoID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter VideoID: %s", err))
		}

		params.VideoID = VideoID
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter VideoID is required, but not found"))
	}
	// ------------- Required header parameter "timestamp" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("timestamp")]; found {
		var Timestamp string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for timestamp, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "timestamp", runtime.ParamLocationHeader, valueList[0], &Timestamp)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timestamp: %s", err))
		}

		params.Timestamp = Timestamp
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter timestamp is required, but not found"))
	}
	// ------------- Required header parameter "message" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("message")]; found {
		var Message []byte
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for message, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "message", runtime.ParamLocationHeader, valueList[0], &Message)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter message: %s", err))
		}

		params.Message = Message
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter message is required, but not found"))
	}
	// ------------- Required header parameter "Type" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Type")]; found {
		var Type string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Type, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Type", runtime.ParamLocationHeader, valueList[0], &Type)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Type: %s", err))
		}

		params.Type = Type
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Type is required, but not found"))
	}
	// ------------- Required header parameter "Color" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Color")]; found {
		var Color string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Color, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Color", runtime.ParamLocationHeader, valueList[0], &Color)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Color: %s", err))
		}

		params.Color = Color
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Color is required, but not found"))
	}
	// ------------- Required header parameter "FontSize" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("FontSize")]; found {
		var FontSize string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for FontSize, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "FontSize", runtime.ParamLocationHeader, valueList[0], &FontSize)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter FontSize: %s", err))
		}

		params.FontSize = FontSize
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter FontSize is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateDanmaku(ctx, params)
	return err
}

// GetDanmaku converts echo context to params.
func (w *ServerInterfaceWrapper) GetDanmaku(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDanmaku(ctx, id)
	return err
}

// DeleteArchiveRequest converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteArchiveRequest(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteArchiveRequestParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "downloadID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("downloadID")]; found {
		var DownloadID int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for downloadID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "downloadID", runtime.ParamLocationHeader, valueList[0], &DownloadID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter downloadID: %s", err))
		}

		params.DownloadID = DownloadID
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter downloadID is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteArchiveRequest(ctx, params)
	return err
}

// DeleteComment converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteComment(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteCommentParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("id")]; found {
		var Id int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationHeader, valueList[0], &Id)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
		}

		params.Id = Id
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter id is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteComment(ctx, params)
	return err
}

// EmailValidation converts echo context to params.
func (w *ServerInterfaceWrapper) EmailValidation(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params EmailValidationParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "email" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("email")]; found {
		var Email string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for email, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "email", runtime.ParamLocationHeader, valueList[0], &Email)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
		}

		params.Email = Email
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter email is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EmailValidation(ctx, params)
	return err
}

// FollowFeed converts echo context to params.
func (w *ServerInterfaceWrapper) FollowFeed(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FollowFeedParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "showMature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("showMature")]; found {
		var ShowMature bool
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for showMature, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "showMature", runtime.ParamLocationHeader, valueList[0], &ShowMature)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter showMature: %s", err))
		}

		params.ShowMature = ShowMature
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter showMature is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FollowFeed(ctx, params)
	return err
}

// Follow converts echo context to params.
func (w *ServerInterfaceWrapper) Follow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Follow(ctx, id)
	return err
}

// GetUnapprovedVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetUnapprovedVideos(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUnapprovedVideosParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUnapprovedVideos(ctx, params)
	return err
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LoginParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "username" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("username")]; found {
		var Username string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for username, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("form", false, "username", runtime.ParamLocationHeader, valueList[0], &Username)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
		}

		params.Username = Username
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter username is required, but not found"))
	}
	// ------------- Required header parameter "password" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("password")]; found {
		var Password string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for password, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("form", false, "password", runtime.ParamLocationHeader, valueList[0], &Password)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter password: %s", err))
		}

		params.Password = Password
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter password is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Login(ctx, params)
	return err
}

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Logout(ctx)
	return err
}

// NewArchiveRequest converts echo context to params.
func (w *ServerInterfaceWrapper) NewArchiveRequest(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params NewArchiveRequestParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "url" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("url")]; found {
		var Url string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for url, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "url", runtime.ParamLocationHeader, valueList[0], &Url)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter url: %s", err))
		}

		params.Url = Url
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter url is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewArchiveRequest(ctx, params)
	return err
}

// Recommendations converts echo context to params.
func (w *ServerInterfaceWrapper) Recommendations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RecommendationsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}
	// ------------- Required header parameter "showMature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("showMature")]; found {
		var ShowMature bool
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for showMature, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "showMature", runtime.ParamLocationHeader, valueList[0], &ShowMature)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter showMature: %s", err))
		}

		params.ShowMature = ShowMature
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter showMature is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Recommendations(ctx, id, params)
	return err
}

// Register converts echo context to params.
func (w *ServerInterfaceWrapper) Register(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParams
	// ------------- Required query parameter "VerificationCode" -------------

	err = runtime.BindQueryParameter("form", true, true, "VerificationCode", ctx.QueryParams(), &params.VerificationCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter VerificationCode: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "username" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("username")]; found {
		var Username string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for username, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationHeader, valueList[0], &Username)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
		}

		params.Username = Username
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter username is required, but not found"))
	}
	// ------------- Required header parameter "password" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("password")]; found {
		var Password string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for password, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "password", runtime.ParamLocationHeader, valueList[0], &Password)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter password: %s", err))
		}

		params.Password = Password
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter password is required, but not found"))
	}
	// ------------- Required header parameter "email" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("email")]; found {
		var Email string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for email, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "email", runtime.ParamLocationHeader, valueList[0], &Email)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
		}

		params.Email = Email
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter email is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Register(ctx, params)
	return err
}

// ResetPassword converts echo context to params.
func (w *ServerInterfaceWrapper) ResetPassword(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ResetPasswordParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "oldpassword" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("oldpassword")]; found {
		var Oldpassword string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for oldpassword, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "oldpassword", runtime.ParamLocationHeader, valueList[0], &Oldpassword)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter oldpassword: %s", err))
		}

		params.Oldpassword = Oldpassword
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter oldpassword is required, but not found"))
	}
	// ------------- Required header parameter "newpassword" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("newpassword")]; found {
		var Newpassword string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for newpassword, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "newpassword", runtime.ParamLocationHeader, valueList[0], &Newpassword)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newpassword: %s", err))
		}

		params.Newpassword = Newpassword
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter newpassword is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ResetPassword(ctx, params)
	return err
}

// RetryArchiveRequest converts echo context to params.
func (w *ServerInterfaceWrapper) RetryArchiveRequest(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params RetryArchiveRequestParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "downloadID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("downloadID")]; found {
		var DownloadID int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for downloadID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "downloadID", runtime.ParamLocationHeader, valueList[0], &DownloadID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter downloadID: %s", err))
		}

		params.DownloadID = DownloadID
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter downloadID is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RetryArchiveRequest(ctx, params)
	return err
}

// UnapproveDownload converts echo context to params.
func (w *ServerInterfaceWrapper) UnapproveDownload(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UnapproveDownloadParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "videoID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("videoID")]; found {
		var VideoID int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for videoID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "videoID", runtime.ParamLocationHeader, valueList[0], &VideoID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoID: %s", err))
		}

		params.VideoID = VideoID
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter videoID is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UnapproveDownload(ctx, params)
	return err
}

// UpdateProfile converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProfile(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateProfileParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "username" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("username")]; found {
		var Username []byte
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for username, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationHeader, valueList[0], &Username)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
		}

		params.Username = Username
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter username is required, but not found"))
	}
	// ------------- Required header parameter "gender" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("gender")]; found {
		var Gender []byte
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for gender, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "gender", runtime.ParamLocationHeader, valueList[0], &Gender)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gender: %s", err))
		}

		params.Gender = Gender
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter gender is required, but not found"))
	}
	// ------------- Required header parameter "birthdate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("birthdate")]; found {
		var Birthdate string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for birthdate, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "birthdate", runtime.ParamLocationHeader, valueList[0], &Birthdate)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter birthdate: %s", err))
		}

		params.Birthdate = Birthdate
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter birthdate is required, but not found"))
	}
	// ------------- Required header parameter "bio" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("bio")]; found {
		var Bio []byte
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for bio, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "bio", runtime.ParamLocationHeader, valueList[0], &Bio)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bio: %s", err))
		}

		params.Bio = Bio
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter bio is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateProfile(ctx, params)
	return err
}

// Upload converts echo context to params.
func (w *ServerInterfaceWrapper) Upload(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "tags" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tags")]; found {
		var Tags []string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for tags, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "tags", runtime.ParamLocationHeader, valueList[0], &Tags)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
		}

		params.Tags = Tags
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter tags is required, but not found"))
	}
	// ------------- Required header parameter "title" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("title")]; found {
		var Title string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for title, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "title", runtime.ParamLocationHeader, valueList[0], &Title)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
		}

		params.Title = Title
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter title is required, but not found"))
	}
	// ------------- Required header parameter "description" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("description")]; found {
		var Description string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for description, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "description", runtime.ParamLocationHeader, valueList[0], &Description)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
		}

		params.Description = Description
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter description is required, but not found"))
	}
	// ------------- Required header parameter "category" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("category")]; found {
		var Category string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for category, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "category", runtime.ParamLocationHeader, valueList[0], &Category)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category: %s", err))
		}

		params.Category = Category
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter category is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Upload(ctx, params)
	return err
}

// Upvote converts echo context to params.
func (w *ServerInterfaceWrapper) Upvote(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpvoteParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "score" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("score")]; found {
		var Score float32
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for score, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "score", runtime.ParamLocationHeader, valueList[0], &Score)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter score: %s", err))
		}

		params.Score = Score
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter score is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Upvote(ctx, id, params)
	return err
}

// UpvoteVideo converts echo context to params.
func (w *ServerInterfaceWrapper) UpvoteVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpvoteVideoParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "score" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("score")]; found {
		var Score int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for score, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "score", runtime.ParamLocationHeader, valueList[0], &Score)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter score: %s", err))
		}

		params.Score = Score
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter score is required, but not found"))
	}
	// ------------- Optional header parameter "Cookie" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cookie")]; found {
		var Cookie string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cookie, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, valueList[0], &Cookie)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cookie: %s", err))
		}

		params.Cookie = &Cookie
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpvoteVideo(ctx, id, params)
	return err
}

// Users converts echo context to params.
func (w *ServerInterfaceWrapper) Users(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "showMature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("showMature")]; found {
		var ShowMature bool
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for showMature, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "showMature", runtime.ParamLocationHeader, valueList[0], &ShowMature)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter showMature: %s", err))
		}

		params.ShowMature = ShowMature
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter showMature is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Users(ctx, id, params)
	return err
}

// Videos converts echo context to params.
func (w *ServerInterfaceWrapper) Videos(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VideosParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "search" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("search")]; found {
		var Search []byte
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for search, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "search", runtime.ParamLocationHeader, valueList[0], &Search)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
		}

		params.Search = &Search
	}
	// ------------- Optional header parameter "sortCategory" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("sortCategory")]; found {
		var SortCategory string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for sortCategory, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "sortCategory", runtime.ParamLocationHeader, valueList[0], &SortCategory)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortCategory: %s", err))
		}

		params.SortCategory = &SortCategory
	}
	// ------------- Optional header parameter "order" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("order")]; found {
		var Order string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for order, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "order", runtime.ParamLocationHeader, valueList[0], &Order)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
		}

		params.Order = &Order
	}
	// ------------- Optional header parameter "unapproved" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("unapproved")]; found {
		var Unapproved string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for unapproved, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "unapproved", runtime.ParamLocationHeader, valueList[0], &Unapproved)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unapproved: %s", err))
		}

		params.Unapproved = &Unapproved
	}
	// ------------- Required header parameter "showMature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("showMature")]; found {
		var ShowMature bool
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for showMature, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "showMature", runtime.ParamLocationHeader, valueList[0], &ShowMature)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter showMature: %s", err))
		}

		params.ShowMature = ShowMature
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter showMature is required, but not found"))
	}
	// ------------- Optional header parameter "pageNumber" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("pageNumber")]; found {
		var PageNumber int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for pageNumber, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "pageNumber", runtime.ParamLocationHeader, valueList[0], &PageNumber)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageNumber: %s", err))
		}

		params.PageNumber = &PageNumber
	}
	// ------------- Optional header parameter "category" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("category")]; found {
		var Category []byte
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for category, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "category", runtime.ParamLocationHeader, valueList[0], &Category)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category: %s", err))
		}

		params.Category = &Category
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Videos(ctx, params)
	return err
}

// VideoDetail converts echo context to params.
func (w *ServerInterfaceWrapper) VideoDetail(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id float32

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.VideoDetail(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/approve-download", wrapper.ApproveDownload)
	router.POST(baseURL+"/approve-video", wrapper.ApproveVideo)
	router.GET(baseURL+"/archive-events", wrapper.ArchiveEvents)
	router.GET(baseURL+"/archive-requests", wrapper.ArchiveRequests)
	router.GET(baseURL+"/audit-events", wrapper.AuditEvents)
	router.POST(baseURL+"/comment", wrapper.Comment)
	router.GET(baseURL+"/comments/:id", wrapper.Comments)
	router.POST(baseURL+"/danmaku", wrapper.CreateDanmaku)
	router.GET(baseURL+"/danmaku/:id", wrapper.GetDanmaku)
	router.POST(baseURL+"/delete-archive-request", wrapper.DeleteArchiveRequest)
	router.POST(baseURL+"/delete_comment", wrapper.DeleteComment)
	router.POST(baseURL+"/email-verification", wrapper.EmailValidation)
	router.GET(baseURL+"/follow-feed", wrapper.FollowFeed)
	router.POST(baseURL+"/follow/:id", wrapper.Follow)
	router.GET(baseURL+"/get-unapproved-videos", wrapper.GetUnapprovedVideos)
	router.POST(baseURL+"/login", wrapper.Login)
	router.GET(baseURL+"/logout", wrapper.Logout)
	router.POST(baseURL+"/new-archive-request", wrapper.NewArchiveRequest)
	router.GET(baseURL+"/recommendations/:id", wrapper.Recommendations)
	router.POST(baseURL+"/register", wrapper.Register)
	router.POST(baseURL+"/reset_password", wrapper.ResetPassword)
	router.POST(baseURL+"/retry-archive-request", wrapper.RetryArchiveRequest)
	router.POST(baseURL+"/unapprove-download", wrapper.UnapproveDownload)
	router.POST(baseURL+"/update-profile", wrapper.UpdateProfile)
	router.POST(baseURL+"/upload", wrapper.Upload)
	router.GET(baseURL+"/upvote/:id", wrapper.Upvote)
	router.POST(baseURL+"/upvotevideo/:id", wrapper.UpvoteVideo)
	router.GET(baseURL+"/users/:id", wrapper.Users)
	router.GET(baseURL+"/videos", wrapper.Videos)
	router.GET(baseURL+"/videos/:id", wrapper.VideoDetail)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xc3W/jNhL/Vwi+9MWO0xZ3B/jpNvHuIofsXpCPfTkUBi2ObXYlUiUp53yB//cDSX1Y",
	"NmnJkeJN2jwUdcQRh5z5zSepfcKMzwUeP+FIcE0ibX5CQliMx3gpJDH//fy3v//jnwvz8CwSCR5gThLA",
	"Y3wjRaKzGaAPN1foHkiCNwNMQUWSpZoJjsf4fulG50KighwPcMwi4AoMs3yui7vJ8Bc8wJm0nLVO1Xg0",
	"WjC9zGaG66hYDIXVKJUiAb2ETJn5RrNYzEYJYXx0fXX58evdR7MOzXRcW+QFib4Dp2Y5eIBXIJVb4vnZ",
	"+dnP5g2RAicpw2P869n52Tke4JTopTKLHJE0lWIFQyoeeSwINQ9Toay4RAqSmP1eUTzGHxzlpCA0s0iS",
	"gAap8Pg/TzsCWjEKAl1NkBaIVu8wM7YEQkFW8ra0VxM8wBL+yJgEisdaZjDAKlpCQsxi9Do1pIxrWIDE",
	"m81glyPJ9BJFQnxnoBDoKMTt0pJgz+RKS8YXeLP5zaxEpYIrsGL65fzc/K/Oj0IMGpDKogiUchCZkyzW",
	"+6QPHP6bQqSBIpBS2OVjlSUJkWs8xreg5RoRGS3ZCpCRAShtaUr9WBE1KuebpXqzmkmIzqRXMzMhYiD8",
	"Nag918hL6909HMIKuLaLWYBP747so6NqUHyhbMSo0f2cxRokEjwksYK+nf6bpGj8MHC7B5KmMYvsLka/",
	"K7O2p635mIbEvphKs1nN3DRfQCmyAA/HAb4hkoN+MC7WM3rPElCaJKl31NqM/1Xjbd0TMfsdIo2rB0RK",
	"ssabzV5giJnSSMzRXMSxeERzAIqsFXVCymfQJU5ySNRgkmOnESi3BV0DVF7eqLrCId8Q/eZk6/FDA2wi",
	"o5jPP5FIC+knucykBK7vhSbxoakmlS14x6+J0ndrHgH1guyBF8ZEZjEcYhQC8YMC6WfeBaU7vqc3jFbz",
	"WZRmlOlGV2aI2jmyHDsoJQtAPEtmFpJegBqSrwVFlxiWKZBtHSejrz6VeTe/v475RSJJcl37s8fLnKDB",
	"7FJidIXy6ZBNCwJGJ910XWygYJPkcT/AqwDyIWZzIROiTRq51maivTAf4P2TQkWy/OcqXXKF95HDFlMJ",
	"joiTVg10avTE6Cbo9PO3VduapRCMKWCf729fyCcaLQoJdDpbTyPn2KYmbPjqmME2tz1vE0kgOuDL5lkc",
	"u317Btn2O3lk3AzMOucshmnKIlNhTbOAl8vSldAwjURWW1g1kdnOdEnU1PhTQ0v9myvp3IzUX8od7zgX",
	"oHOTpKAJi5VtwBCkUojYnEUFAru50QK7dvISehbWlPCEfM8O+FKruklO1rYUN4xo+Y7X9r/14ml0UQu1",
	"YVkSH1X/7fFs8ODVcI8e3BCYCBuVoc3L+97M02lzRZiKRCxk2G+7wR74zIXx2+x/QXF+ElzfufHONXt9",
	"CTmokfVOTPBewoc1F8ThsQTjtp0djh6fQR9paK86fnyw8SOU4joM+bz2Za6PCdH+qFBCwjcY4neo33K4",
	"o2KNqt9uyjY26r46H6lcdY4f25wd7vRHwm57YunrXZLW/bSriVmjXpaJt6kSJWi57qe19ldrejsm08a6",
	"xSmtZfXSXLa8gbLdn8Y7edEu2nCiRKQMmFYR9sBsuAJpciviZgop46Oh/UZiRh1hgzrcWVxAQMVgzwHM",
	"LhGtyjX2HMBgZ3onQ9cIHs7BZcHeQPbJ0nwyJA1iU0vxiMpzEq/wDMmXgqJRglU6frqoVtUTbvBrqJy5",
	"Jdr88r15v8ySGScsvhZRIEbZc9JQx3+SyRLQe5MXubZ/DB6VZ+T1HBY82JqrXo47DmU65TdhB8MmCNpO",
	"6AunUnWObl19WKtPNAvQw4znx3p0uCq7g6Gc86EkzjuJb/4w5ZJoWAgjIW9P9PY6bEevuyl6IMmIxYId",
	"CGfXdrjJG4OZGuUiCajV2Iv9eUQ8G2Cl1/aah6l88X6qoYTUKCrUFuzDKvUoJO3CuZWBWmH1YZ/XYmHz",
	"aHfawktNiUwHLfLaDbdcp8jKtuc8i7uu1a7TcLcL5fDYvuL4Co/HlRuZjE1dkTMIok3G3RoNJ79PYfdD",
	"4p6TMa/NS3DprcvPGnrTt3Xi07YYXlItg4aI/p5QvvmE0oFxB+5d2+K1yVVhUQumtDvj8Pu524KiRVpp",
	"AOd6J+U7vYXUE8bQZ7I6vurd47NdqqNI0DJM/JGBZVwcJmzRXTqyvpN2p0O5VWgD7dajKJBko24BPwV6",
	"WuroAAgV6JtKlQeRKGKKttTu1ZWIaT/IMLGqiRmHx36YnTq2FxJH0ZLwRVftK9CVqHL1a7lun3LZauC9",
	"x9tsuaZoetkWb1lwt7h5Xtbb73fPT9qGz1JKNAzzywMH9GPpbnKyBt0Yf7cVvp8f3o8+EjacF8BpOK0o",
	"R3vmOmNSL42MQoy3CTrGkhkTYS6i095aIdOBAeWg6adnZ2c0oPhJFRMXCG3wHGkbd1FPmjVZqOCFCDcW",
	"FmFZsuzVCDuZ+8Dvs9zHPcHrGG6wS36Y352pnoWCV42ky72FhqR3a/zI0x7rqS4EXe8UlUkWa5YSqUcG",
	"0ENKNKnXlfVy0qCpuE9Vqq8yBcaJXVyjQneLNVudnbgl5fCOiO2AbLW43S2sw+0O1xo//hS15z6HWypS",
	"kThwwpUPNvKpSukfHbDzg4ce3KGpxG3DJrdlA+8tJdunDec8bjFHfSz2FrT9ivKz/tTtO7Ey6m9oXj4Y",
	"kpOe5L2VrmLd+18w4Q3XF2VG5hv97BJF39C/BAtfxLohC8aLu1qe1eSfQ9zU711VrUL3Jcu/51c7acah",
	"lmGel9+4q7+hs7y97xsqpg9FNh5sfar3bm2bbq0nRfgx95u94aPh3LvdUXerA1FHhDuVVa0aqobosqLp",
	"u18rpPuz73mrywhHTv5yd4MG+98CHffp3VFf/rQvGToXr88MGzmq8r+CtyokZZzETK/93tzv95o9yXsg",
	"eQ8kDYGkflaHCKcoLTGTe/3+TwPd78OZqZOajW6nKD5KsfbrAA6isfyqrRqsdPnlZhKCWt3CjkYyWahj",
	"elBb2D8S+K7NEMxyjZ1PthUZoLnLZoZoZpX/LH/RxOVUFvqjErk9GzQUIFeFOVX/6NB4NIpFROKlUHr8",
	"6/n5+YikDG9+2/w/AAD///SY6KApSQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
